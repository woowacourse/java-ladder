# java-ladder

사다리 타기 미션 저장소

## 우아한테크코스 코드리뷰

- [온라인 코드 리뷰 과정](https://github.com/woowacourse/woowacourse-docs/blob/master/maincourse/README.md)

---

## 용어 정의

- 디딤판(step): 사다리 기둥 사이를 연결하는 발판을 의미한다.
- 존재여부(doesExist): 디딤판이 존재하는지를 나타낸다. true이면 디딤판이 있고, false이면 없다.
- 사다리층(layer): 사다리의 각 층을 의미한다.
- 사다리(ladder): 사다리 전체를 의미한다.
- 결과 이름(prize): 사다리 실행 후 나올 수 있는 각 결과의 이름을 의미한다.

## 구현할 기능 목록

### 입력

- [x] 참여할 사람 이름을 입력받는다.
    - [x] 쉼표로 구분한다.
    - [x] 참여할 사람은 두명 이상이어야한다.
    - [x] 이름은 빈값 혹은 공백만을 입력할 수 없다.
    - [x] 이름은 최대 다섯글자까지 입력 가능하다.
    - [x] 이름은 중복될 수 없다.
    - [x] "all" 이라는 이름은 입력할 수 없다.
- [x] 최대 사다리 높이를 입력받는다.
    - [x] 사다리 높이는 숫자이어야한다.
    - [x] 사다리 높이는 1 이상이어야한다.
- [x] 실행 결과를 입력받는다.
    - [x] 쉼표로 구분한다.
    - [x] 결과 이름으로 빈값 혹은 공백을 입력할 수 없다.
    - [x] 결과 이름은 최대 다섯글자까지 입력 가능하다.
    - [x] 결과의 갯수는 참여한 사람 수와 같아야한다.
- [x] 결과를 보고싶은 사람 이름을 입력받는다.
    - [x] 참여한 사람 목록에 일치하는 이름이 있어야한다.
- [x] 사용자가 잘못된 입력을 하면 해당 부분부터 다시 입력받는다.

### 사다리 생성

- [x] 각 사다리층에는 (참여자수 - 1)개 만큼의 디딤판을 생성할 수 있는 공간이 있다.
    - [x] 디딤판 존재여부는 true, false 중 랜덤으로 결정된다.
    - [x] 디딤판이 같은 층에서 연속해서 생성되지 않도록 한다.

### 사다리 출력

- [x] 사람 이름을 5자 기준으로 출력한다.
- [x] 사다리를 출력한다.
    - [x] 사다리 맨 아래에는 실행 결과가 출력된다.

### 사다리 실행

- [x] 해당 위치 앞뒤에 디딤판이 존재하면 디딤판 방향으로 이동한 뒤 아래칸으로 이동한다.
- [x] 이동할 수 있는 디딤판이 존재하지 않으면 아래칸으로 이동한다.
- [x] 사다리 양 끝단에 도달하면 아래칸으로 이동한다.
- [x] 사다리 맨 아래층에 도달하면 사다리 실행이 종료된다.

### 사다리 실행 결과 출력

- [x] 이름에 맞는 실행 결과를 출력한다.
- [x] all을 입력하면 전체 실행 결과를 출력한다.

---

## 고민한 포인트

### [ 레벨2 ]

> 객체 역할에 대한 고민, 각 객체가 자신의 역할을 할 수 있도록한다.

- 각 Layer가 생성되는 과정에서 random값 까지 생성해서 넣어주는것이 layer의 역할일까? 에 대한 의문이 생겼습니다.
    - 결론: 랜덤값 생성 부분은 stepExistenceGenerator에서 생성하고, 그 값을 layer가 받아서 사용하도록 변경하였습니다.
- Layer에서는 Step 상태에 따라 한 층에서 이동하는것을 관리하고, ladder에서는 전체 layer를 순회하며 이동하는것을 담당하도록 했습니다.
- GameResults는 결과를 관리하는 객체로, Ladder에서 결과를 생성한 뒤 GameResults로 데이터를 넘겨주도록 했습니다.
    - 결과 조회를 할 때 한명씩 조회할수도, 전체를 조회할수도 있으며 조회한 사람을 또 조회할수도 있으므로<br>
      처음 한번만 전체 사다리 타기를 실행한 후 해당 결과에서 값을 조회해서 전달하는 방식을 사용했습니다.

> GameResults, GameResultsDto의 역할

- ladder에서 전체 사다리 타기를 한 뒤 Participants, Prizes의 값을 참고해 최종 결과인 Map<Participant, Prize>을 구했습니다.<br>
  그러나 실질적으로 결과 출력을 위해 필요한 것은 Map<ParticipantName, PrizeName> 이었습니다.
- 처음부터 모델 로직에서 필요한 형태로 리턴해주는것이 더 효율적인가? 하는 궁금증이 생겼습니다.
    - 결론: dto는 데이터를 전달하는데 사용되는 객체로, 도메인 로직의 리턴형태로는 적합하지 않다고 판단했습니다.<br>
      ladder에서는 Map<Participant, Prize> 형태를 리턴하고 이를 관리하는 GameResults에서<br>
      Dto 객체를 통해 Map<ParticipantName, PrizeName>를 view로 전달하도록 했습니다.

> 요구사항에 명시되지 않은 추가 기능

- 요구 사항의 결과 조회부분은 조회하고자하는 사람 이름을 반복적으로 입력받도록 되어있습니다.
    - 종료되는 조건에 대한 언급이 없어 해당 부분은 우선 구현하지 않았습니다.
    - 필요하다면 특정 키워드를 입력하면 종료하거나, 몇 회 이상 조회 후 종료되는 방식을 적용해볼 수 있을것 같습니다.
- 참여자 이름으로 "all"을 입력할 수 있는가
    - (1) 사용자 이름으로 "all"을 허용하되 조회할 이름으로 "all"을 입력하면 전체 결과를 출력한다.
    - (2) 사용자 이름으로 "all"을 허용하고 조회할 이름으로 "all"을 입력하면 해당 참여자에 대한 결과만 출력할지, 전체를 출력할지 확인한다.
    - (3) 사용자 이름으로 "all"을 허용하지 않고 전체 조회에만 사용한다.
    - 크게 세가지 방식을 생각해볼 수 있었습니다. 기능을 좀 더 명확히 구분하기 위해 (3) 방식을 적용했습니다.

> Height 원시 타입 포장

- 사다리 높이를 나타내는 int height를 Height로 포장하여 자체적으로 유효성 검증을 하도록 했습니다.

---

### [ 레벨1 ]

> TDD 연습을 위해 TDD Cycle에 따라 실패하는 테스트, 프로덕션 코드, 리팩토링으로 구분해서 커밋한다.

- 구현 초기에는 TDD 방식은 처음이라 테스트코드 작성, 도메인 로직 작성, 리팩토링 각각 커밋을 진행했습니다.
    - 저희가 구현한 방식이 TDD cycle을 잘 준수했는지 궁금합니다.
- 초반에는 TDD 방식을 제대로 하고 있는지 피드백 받기 위해 각각 커밋했으며 이후 기능 단위로 커밋을 진행했습니다.
- 생성자 테스트는 어떻게 해야할지, 어느 범위까지 해야할지 고민했습니다.
    - 예외 발생 케이스에 대해서만 검증하는 방식으로 진행했습니다.

> DTO 생성을 어디서 해야할까

- DTO 생성 로직이 컨트롤러에 들어가야할지, 모델에 들어가야할지 고민했습니다.
    - 우리의 결론: DTO는 데이터를 전달해주는 역할을 하므로 모델에서 생성해서 컨트롤러에 전달해준다.
    - 위치: Participants의 captureParticipantsName(), Ladder의 captureLayerSteps()

> View에서 어느정도 형태까지 변환해야할까

- InputView에서 입력받은 String으로 그대로줄지, 아니면 기본적인 형태변환까지는 해주어도 될까
    - 우리의 결론: 도메인으로 변환하는것은 안되지만, 모델에 값을 전달하기 위한 최소한의 형태까지는 변경할 수 있다.
- OutputView에서 전달받은 DTO를 순환하거나 값을 가져와서 출력하기 위한 로직이 들어가는게 맞는가
    - 우리의 결론: DTO가 데이터 전달을 위한것이라서 해당 데이터를 출력 형태로 변환하는것까지는 가능하다.

> StepExistenceGenerator 의 generate() 메서드를 static으로 작성

- Layer를 생성할때마다 Random 객체를 새로 생성하는것이 불필요하다는 생각이 들어서 반복되는 로직을 바로 사용할 수 있도록 static으로 작성하였습니다.

> Test만을 위한 getter 메서드가 존재해도 될까

- TDD 방식으로 코드를 구현하다보니 도메인에 getter 메서드를 사용하게 되었습니다.
- 나중에 보니 getter가 테스트 코드에만 사용되고 있었습니다.
    - 우리의 결론: 테스트를 위해 도메인 로직이 변경되는것은 아니니 사용해도 괜찮다고 생각.

> 재귀함수 사용

- 사용자가 입력을 잘못 입력했을때 재입력을 받는 과정을 구현하기 위해 재귀함수를 사용했습니다.
- 재귀함수의 경우 스택오버플로우의 가능성도 있다고 들었는데, 실제 현업에서 사용이 되는 방식인지 궁금합니다.
